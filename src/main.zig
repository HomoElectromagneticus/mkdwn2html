const std = @import("std");

fn handleHeaderLine(markdown_line: []const u8, html: *std.ArrayListAligned(u8,null)) !void {
    // count the number of '#' at the beginning of the line
    var header_level: u8 = 0;
    for (markdown_line) |character| {
        if (character == '#') {
            header_level += 1;
        }
    }
    // use the calculated header level to build the appropriate html tags 
    try html.*.writer().print("<h{d}>", .{header_level}); 
    try html.*.appendSlice(markdown_line[header_level..]);
    try html.*.writer().print("</h{d}>", .{header_level}); 
}

test "first-level header" {
    const markdown: []const u8 = "#Header 1";
    var test_html = std.ArrayList(u8).init(std.testing.allocator);
    defer test_html.deinit();
    try handleHeaderLine(markdown, &test_html);
    try std.testing.expectEqualStrings("<h1>Header 1</h1>", test_html.items);
}

test "third-level header" {
    const markdown: []const u8 = "###Header 3";
    var test_html = std.ArrayList(u8).init(std.testing.allocator);
    defer test_html.deinit();
    try handleHeaderLine(markdown, &test_html);
    try std.testing.expectEqualStrings("<h3>Header 3</h3>", test_html.items);
}

fn parseMarkdown(markdown: []const u8, html: *std.ArrayListAligned(u8,null)) !void {
    // handle empty input
    if (markdown.len == 0) return; 
    
    // split the markdown input on newlines
    var markdown_split = std.mem.splitSequence(u8, markdown, "\n");

    // we need to know if we are inside a paragraph
    while (markdown_split.next()) |line| {
        // nothing to do on empty lines (for now...)
        if (std.mem.eql(u8, line, "\n") or line.len == 0) {
            try html.*.append('\n');
            continue;
        }
        // check and handle headers
        if (line[0] == '#') {
            try handleHeaderLine(line, html);
            continue;
        }
        try html.*.appendSlice(line);
        try html.*.append('\n');
    } else {
        // remove trailing newline generated by the above loop
        _ = html.*.pop();
    }
}

test "empty input" {
    var test_html = std.ArrayList(u8).init(std.testing.allocator);
    defer test_html.deinit();
    try parseMarkdown("", &test_html);
    try std.testing.expectEqual(0, test_html.items.len);
}

pub fn main() !void {
    // stdout is for the actual output of your application, for example if you
    // are implementing gzip, then only the compressed bytes should be sent to
    // stdout, not any debugging messages.
    const stdout_file = std.io.getStdOut().writer();
    var bw = std.io.bufferedWriter(stdout_file);
    const stdout = bw.writer();

    // we'll hardcode the file path and max size for now (path is relative to
    // where the program is run from, and not this file)
    const path = "src/test.md";
    const max_bytes : u16 = 32768;      //32 kB ish
    // open the markdown file
    const input_file = try std.fs.cwd().openFile(path, .{});
    defer input_file.close();

    // we will need to allocate memory in order to read and handle the markdown
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    // store the markdown file contents in this variable
    const markdown = try input_file.readToEndAlloc(gpa.allocator(), max_bytes);
    defer gpa.allocator().free(markdown);

    // print a copy of the markdown for debugging
    try stdout.print("Markdown input:\n{s}", .{markdown});

    // we'll need to allocate more memory to build the output html content
    var html = std.ArrayList(u8).init(gpa.allocator());
    defer html.deinit();
  
    // add the opening html tags, parse the markdown, and then add the closing
    // html tags (with newlines so it's more readable)
    try html.appendSlice("<html>\n");
    try parseMarkdown(markdown, &html); 
    try html.appendSlice("\n</html>");

    // print the html for debugging
    try stdout.print("\nHTML output:\n{s}\n", .{html.items});
    
    try bw.flush(); // don't forget to flush!
}

